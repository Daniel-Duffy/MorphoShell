/*
/////////////////////////////////////////////////////

/////////////////////////////////////////////////////




        ////////////////////////////////////////////////////////////////////

        // CAUCHY STRESS
        Eigen::Matrix<double,3,3> cauchyStress = sqrt(triangles[i].detInvMetric) * (2.0 * triangles[i].halfPK1Stress) * triangles[i].defGradient.transpose();

        // For future reference: a second argument can be supplied to only
        // calculate the eigenvalues, without the eigenvectors.
        Eigen::SelfAdjointEigenSolver<Eigen::Matrix<double,3,3>> eigenSolver(cauchyStress);

        // Find smallest-magnitude eigenvalue (which should be zero, to within
        // floating point noise), and retain the other two, which are the ones
        // we care about. Store also the corresponding two eigenvecs.
        int minMagEigenvalIdx = 0;
        for(int j = 0; j < 3; ++j){
            if( fabs(eigenSolver.eigenvalues()(minMagEigenvalIdx)) > fabs(eigenSolver.eigenvalues()(j)) ){
                minMagEigenvalIdx = j;
            }
        }
        cauchyStressEigenvals.at(i)(0) = eigenSolver.eigenvalues()((1 + minMagEigenvalIdx)%3);
        cauchyStressEigenvecs.at(i).col(0) = eigenSolver.eigenvectors().col((1 + minMagEigenvalIdx)%3);
        cauchyStressEigenvals.at(i)(1) = eigenSolver.eigenvalues()((2 + minMagEigenvalIdx)%3);
        cauchyStressEigenvecs.at(i).col(1) = eigenSolver.eigenvectors().col((2 + minMagEigenvalIdx)%3);
    }




*/

//Turn Eigen bounds checking off for speed.
#ifndef EIGEN_NO_DEBUG
#define EIGEN_NO_DEBUG
#endif

#include <vector>
#include <Eigen/Dense>

#include "calc_energy_densities.hpp"
#include "Stuff_Class.hpp"

void calc_energy_densities(
    Eigen::Matrix<double,Eigen::Dynamic,2> &energy_densities,
    const Eigen::Matrix<double,Eigen::Dynamic,3> &a_comps,
    const Eigen::Matrix<double,Eigen::Dynamic,3> &b_comps,
    const Eigen::Matrix<double,Eigen::Dynamic,3> &abar_comps,
    const Eigen::Matrix<double,Eigen::Dynamic,3> &bbar_comps,
    const Eigen::Matrix<double,Eigen::Dynamic,1> &def_shear_moduli,
    const Eigen::Matrix<double,Eigen::Dynamic,1> &def_thicknesses,
    const Stuff_Class &stuff){

    for(int t = 0; t < stuff.num_tris; ++t){

        double a0 = a_comps(t,0);
        double a1 = a_comps(t,1);
        double a2 = a_comps(t,2);
        double b0 = b_comps(t,0);
        double b1 = b_comps(t,1);
        double b2 = b_comps(t,2);
        double abar0 = abar_comps(t,0);
        double abar1 = abar_comps(t,1);
        double abar2 = abar_comps(t,2);
        double bbar0 = bbar_comps(t,0);
        double bbar1 = bbar_comps(t,1);
        double bbar2 = bbar_comps(t,2);

        double char_bend_energy_density_for_one_over_thickness_curv = def_shear_moduli(t) * def_thicknesses(t);
        double bend_stiffening_energy_density_scale = stuff.bend_stiffening_scale_factor * char_bend_energy_density_for_one_over_thickness_curv;

        ///////////////////////////////////////////////////////////////////////////////////////
        // Copy-paste the contents of energyDensitiesCpp.txt (generated by Mathematica) between 
        // this comment and the double row of slashes at the end of the for loop.

        
        double stretch_prefac = (-2*def_thicknesses(t)*def_shear_moduli(t)*(1/sqrt(-(abar1*abar1) + abar0*abar2)))/(-1 + stuff.def_poisson_ratio); 

        double bend_prefac = (def_shear_moduli(t)*(def_thicknesses(t)*def_thicknesses(t)*def_thicknesses(t))*(1/sqrt(-(abar1*abar1) + abar0*abar2)))/(6 - 6*stuff.def_poisson_ratio); 

        energy_densities(t,0) = (stretch_prefac*((1 - stuff.def_poisson_ratio)*(2*(abar0*(a1 - abar1) - (a0 - abar0)*abar1)*(-(abar1*(a2 - abar2)) + (a1 - abar1)*abar2) + ((-((a1 - abar1)*abar1) + abar0*(a2 - abar2))*(-((a1 - abar1)*abar1) + abar0*(a2 - abar2))) + ((-((a1 - abar1)*abar1) + (a0 - abar0)*abar2)*(-((a1 - abar1)*abar1) + (a0 - abar0)*abar2))) + stuff.def_poisson_ratio*((-2*(a1 - abar1)*abar1 + abar0*(a2 - abar2) + (a0 - abar0)*abar2)*(-2*(a1 - abar1)*abar1 + abar0*(a2 - abar2) + (a0 - abar0)*abar2))))*0.5; // Stretch 

        double bend_energy_dens_no_stiffening = (bend_prefac*(stuff.def_poisson_ratio*((abar2*b0 - 2*abar1*b1 + abar0*b2 - abar2*bbar0 + 2*abar1*bbar1 - abar0*bbar2)*(abar2*b0 - 2*abar1*b1 + abar0*b2 - abar2*bbar0 + 2*abar1*bbar1 - abar0*bbar2)) + (1 - stuff.def_poisson_ratio)*(2*(abar1*(b0 - bbar0) + abar0*(-b1 + bbar1))*(abar2*(-b1 + bbar1) + abar1*(b2 - bbar2)) + ((abar2*(b0 - bbar0) + abar1*(-b1 + bbar1))*(abar2*(b0 - bbar0) + abar1*(-b1 + bbar1))) + ((abar1*(b1 - bbar1) + abar0*(-b2 + bbar2))*(abar1*(b1 - bbar1) + abar0*(-b2 + bbar2))))))*0.5;  // Bend before bend-stiffening effect included 

        energy_densities(t,1) = bend_energy_dens_no_stiffening * (1 + bend_energy_dens_no_stiffening  / bend_stiffening_energy_density_scale);  // Bend with bend-stiffening included 


        ///////////////////////////////////////////////////////////////////////////////////////
        ///////////////////////////////////////////////////////////////////////////////////////

    }
}
